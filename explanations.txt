model:
1. В этом файле содержится класс Feature, который представляет собой модель, благодаря которой ORM
построит соответствующию таблицу в файле БД sqlite3.

2. Базовый класс позволяет управлять метаданными таблиц (имена таблиц, столбцы, типы данных).
Также этот класс позволяет SQLAlchymy преобразовывать объекты питона в строки таблицы.
Поэтому все модели должны наследоваться от базового класса.

3. Функция для создания БД создает ее с нуля или передает engine уже существующую.
    engine - это объект SQLAlchemy, который управляет соединением с базой данных. 
Он отвечает за выполнение SQL-запросов и создание таблиц.
    Base.metadata.create_all(engine): Base.metadata - объект, который содержит всю информацию о таблицах,
которые были созданы в БД на основе Моделей. Он хранит метаданные класса модели, а не самой таблицы.
create_all(engine) - создает таблицы, которые еще не существуют в БД (на основе Моделей). Не удаляет
и не изменяет существующие!

dbOperations:
1. SessionLocal — это класс для создания сессий. Он использует функцию SQLAlchemy "sessionmaker", 
которая создает фабрику для создания экземпляров сессий.
autocommit=False - изменения только после session.commit()
autoflush=False - предотвращает автоматическую синхронизацию данных с базой до выполнения запроса.
bind=engine - сесси, создаваемые с помощью фабрики, будут связаны с определенным движком.  
*Сессия — это окно для работы с базой данных. Все запросы и изменения в базе данных должны 
происходить в контексте сессии.
Сессии необходимо закрывать, чтобы избежать утечек ресурсов.

2. Контекстный менеджер - тут позволяет автоматически закрывать и открывать сессию БД.
@contextmanager - декаратор, который позволяет написать функцию, работающую как контекстный менеджер, где
логика входа и выхода реализуется через yeld, а не через отдельный класс с методами__enter__ и __exit__.
Блок try гарантирует, что программа будет работать с БД через созданную ранее сессию (пока она активна).
Блок finally гарантирует закрытие сессии.
Yield - возвращает созданную сессию наружу и передает управление коду, использующему этот
контекстный менеджер. 
Все, что будет в контексте активной сессии, т.е. в with get_db_session() as db:
не будет иметь проблем с утечками ресурсов, так как сессия корректно откроется и закроется.
При этом with SessionLocal() as session: не работает, так как SQLAlchemy-сессии сами по себе не 
поддерживают использование с конструкцией with, то есть, они не являются контекстными менеджерами 
по умолчанию!
